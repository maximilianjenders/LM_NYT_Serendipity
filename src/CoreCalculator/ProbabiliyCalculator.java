package CoreCalculator;

import java.util.HashMap;

import dataclass.Article;

import util.Helper;

/***
 * Calculation for probability whether an article was created using a certain language model (theta)
 * @author Max
 *
 */
public class ProbabiliyCalculator {

	/***
	 * Calculates the smoothed log probability of the article being generated by theta, i.e. log P(document | theta). 
	 * log(P) is asymtoptical to P
	 * @param article the article for which the probability of being generated by theta shall be calculated
	 * @param thetaOccurrences the HashMap containing the occurrences for theta
	 * @return log P(article)
	 */
	public static double calculateSmoothedLogProability(Article article, HashMap<Integer, Integer> theta) {
		//n is the number of total word/feature occurrences in the article
		int n = 0;
		HashMap<Integer, Integer> articleOccurrences = article.getOccurrences();
		n = article.getNumOccurrences();

		//probability of document being generated by theta is being calculated by 
		//(n! / (k_1! * ... * k_m!) )* (p_1)^(x_1) * ... * (p_m)^(x_m)
		// = log(n!) - log(k_1!) + ... + log(x_m!) + (k_1)*log(p_1) + ... + (k_m)*log(p_m)
		//WITH SUM(k_i)[i=1...m] = n


		//calculate log(n!)
		double articleProbability = Helper.logFactorial(n);

		//nPrime is the number of total word occurrences in theta
		int nPrime = 0;
		for (int occurrence : theta.values()) {
			nPrime += occurrence;
		}
		//mPrime is the number of unique words in theta
		int mPrime = theta.keySet().size();

		for (int featureID : articleOccurrences.keySet()) {
			//This is k_i, the number of occurences of feature i in the article
			int k_i = articleOccurrences.get(featureID);

			//Then, calculate probabilities based on observed features and their frequencies (From theta)
			//The best estimator for p_i := (k_iPrime) / SUM_x(k_xPrime) = (k_iPrime) / nPrime   || With nPrime = SUM_i(k_iPrime); Probabilities sum up to 1
			//Laplace smoothing: p_i := (k_iPrime + 1) / (nPrime + mPrime) || Probabilities sum up to 1
			double p_i = (theta.get(featureID) == null) ? 1.0 / (mPrime + nPrime) : (theta.get(featureID) + 1.0) / (mPrime + nPrime);

			//now, we add log((p_i^(k_i)) / (k_i)!) = log(p_i) * k_i - log(k_i!)
			articleProbability += (Math.log(p_i) * k_i) - Helper.logFactorial(k_i);
		}

		return articleProbability;
	}
}
